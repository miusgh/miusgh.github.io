<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>逗猫棒调试页面</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #canvas {
            border: 2px solid #333;
            background: #000;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div class="debug-info">
        <div>手部状态: <span id="hand-status">未检测</span></div>
        <div>段数: <span id="segment-count">0</span></div>
        <div>手部位置: <span id="hand-position">无</span></div>
        <div>游戏循环: <span id="game-loop">未启动</span></div>
    </div>

    <div class="controls">
        <button onclick="testPhysics()">测试物理模拟</button>
        <button onclick="testRendering()">测试渲染</button>
        <button onclick="simulateHand()">模拟手部</button>
        <button onclick="resetApp()">重置应用</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        // 简化的逗猫棒应用用于调试
        class DebugCatTeaser {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.isRunning = false;
                this.handDetected = false;
                this.lastHandPosition = null;
                
                // 逗猫棒物理参数
                this.teaserLength = 200;
                this.segmentCount = 20;
                this.segmentLength = this.teaserLength / this.segmentCount;
                this.segments = [];
                this.gravity = 0.5;
                this.damping = 0.95;
                this.stiffness = 0.1;
                
                this.initializeTeaserSegments();
                this.startGameLoop();
            }

            initializeTeaserSegments() {
                this.segments = [];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                for (let i = 0; i < this.segmentCount; i++) {
                    this.segments.push({
                        x: centerX,
                        y: centerY + i * this.segmentLength,
                        vx: 0,
                        vy: 0,
                        targetX: centerX,
                        targetY: centerY + i * this.segmentLength
                    });
                }
                
                console.log('初始化逗猫棒段:', this.segments.length, '段');
                document.getElementById('segment-count').textContent = this.segments.length;
            }

            startGameLoop() {
                this.isRunning = true;
                console.log('游戏循环启动');
                document.getElementById('game-loop').textContent = '运行中';
                this.gameLoop();
            }

            gameLoop() {
                if (!this.isRunning) return;

                this.updateTeaserPhysics();
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }

            updateTeaserPhysics() {
                if (!this.handDetected || !this.lastHandPosition) return;

                const handX = this.lastHandPosition.x;
                const handY = this.lastHandPosition.y;

                this.segments[0].x = handX;
                this.segments[0].y = handY;
                this.segments[0].targetX = handX;
                this.segments[0].targetY = handY;

                for (let i = 1; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const prevSegment = this.segments[i - 1];

                    const dx = segment.x - prevSegment.x;
                    const dy = segment.y - prevSegment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const targetX = prevSegment.x + (dx / distance) * this.segmentLength;
                        const targetY = prevSegment.y + (dy / distance) * this.segmentLength;
                        
                        segment.targetX = targetX;
                        segment.targetY = targetY;
                    }

                    const springX = (segment.targetX - segment.x) * this.stiffness;
                    const springY = (segment.targetY - segment.y) * this.stiffness;
                    const gravityY = this.gravity;

                    segment.vx += springX;
                    segment.vy += springY + gravityY;

                    segment.vx *= this.damping;
                    segment.vy *= this.damping;

                    segment.x += segment.vx;
                    segment.y += segment.vy;
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.handDetected && this.segments.length > 0) {
                    this.drawTeaserStick();
                    
                    // 绘制手部位置点
                    this.ctx.fillStyle = 'yellow';
                    this.ctx.beginPath();
                    this.ctx.arc(this.lastHandPosition.x, this.lastHandPosition.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            drawTeaserStick() {
                this.ctx.save();
                
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.shadowColor = '#ff6b6b';
                this.ctx.shadowBlur = 10;
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.segments[0].x, this.segments[0].y);
                
                for (let i = 1; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    this.ctx.lineTo(segment.x, segment.y);
                }
                
                this.ctx.stroke();
                
                if (this.segments.length > 0) {
                    const lastSegment = this.segments[this.segments.length - 1];
                    this.ctx.fillStyle = '#ff6b6b';
                    this.ctx.shadowBlur = 15;
                    this.ctx.beginPath();
                    this.ctx.arc(lastSegment.x, lastSegment.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }

            setHandPosition(x, y) {
                this.handDetected = true;
                this.lastHandPosition = { x, y };
                document.getElementById('hand-status').textContent = '已检测';
                document.getElementById('hand-position').textContent = `(${Math.round(x)}, ${Math.round(y)})`;
            }

            reset() {
                this.handDetected = false;
                this.lastHandPosition = null;
                document.getElementById('hand-status').textContent = '未检测';
                document.getElementById('hand-position').textContent = '无';
                this.initializeTeaserSegments();
            }
        }

        let debugApp;

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            debugApp = new DebugCatTeaser();
            
            // 添加鼠标事件
            debugApp.canvas.addEventListener('mousemove', (e) => {
                const rect = debugApp.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                debugApp.setHandPosition(x, y);
            });
        });

        // 测试函数
        function testPhysics() {
            if (debugApp) {
                debugApp.setHandPosition(400, 300);
                console.log('物理测试启动');
            }
        }

        function testRendering() {
            if (debugApp) {
                debugApp.setHandPosition(200, 200);
                setTimeout(() => {
                    debugApp.setHandPosition(600, 400);
                }, 1000);
                console.log('渲染测试启动');
            }
        }

        function simulateHand() {
            if (debugApp) {
                let angle = 0;
                const centerX = debugApp.canvas.width / 2;
                const centerY = debugApp.canvas.height / 2;
                const radius = 100;
                
                const interval = setInterval(() => {
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    debugApp.setHandPosition(x, y);
                    angle += 0.05;
                    
                    if (angle > Math.PI * 4) {
                        clearInterval(interval);
                    }
                }, 50);
            }
        }

        function resetApp() {
            if (debugApp) {
                debugApp.reset();
                console.log('应用已重置');
            }
        }
    </script>
</body>
</html>
